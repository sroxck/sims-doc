---
title: 内部类
tags: java
sidebar: auto
date: 2022-01-12 17:56:18
permalink: /pages/880b69/
categories: 
  - 后端
  - Java基础
  - Java
---
# 内部类
一个类内部包含另一个类


## 成员内部类的定义

``` java
public class Outer{ //外部类
    public class Inner{ //内部类

    }
}
```
注意: 内部类用外部类,可以随意访问,外用内,需要借助内部类对象

如何使用成员内部类? 两种方式
1. 间接方法:在外部类的方法中,使用内部类,然后main调用外部类的方法
1. 直接方法:外部类名称.内部类名称 = new 外部类名称().new 内部类名称();
> 内部类访问外部类的变量 外部类名称.this.变量名
## 局部内部类的定义
如果一个类是定义在一个方法内部的.name这就是一个局部内部类
局部: 只有当前所属的方法才能使用它,出了这个方法外面就不能用了

定义格式:
``` java
修饰符 class 外部类名称 {
    修饰符 返回值类型 外部类方法名称(参数列表){
        class 局部内部类名称 {
            //.....
        }
    }
}

类的权限修饰符: public protected (default) private
        
定义一个类的时候,权限修饰符规则:
1. 外部类: public / (default)
2. 成员内部类: public / protected / (default) / private
3. 局部内部类: 什么都不能写,和默认default不一样

```
## 局部内部类的final问题
局部内部类,如果希望访问所在方法的局部变量,那么这个局部变量必须是`有效final的`
局部内部类,如果访问所在方法的局部变量,能保证变量不会被改变,是可以不写final的

原因: 
1. new出来的对象在堆内存中
2. 局部变量是跟着方法走的,在栈内存中
3. 方法运行结束之后.立刻出栈,局部变量会立刻消失
4. new出来的对象,会在堆当中持续存在,直到垃圾回收


# 匿名内部类(重点)
> 如果接口的实现类,或者父类的子类,只需要使用唯一的一次,那么这种情况下,就可以省略掉该类的定义,而改为使用匿名内部类

## 匿名内部类的定义格式
``` java
接口名称 对象名 = new 接口名称() {
    // 覆盖重写,接口中所有抽象方法
};

// 使用匿名内部类
MyInterFace obj = new MyInterFace() {
    @Override
    public void method(){
        // 匿名内部类实现了方法
    }
};
```

## 匿名内部类的注意事项
对格式"new 接口名称(){...}"进行解析:
1. new 代表创建对象的动作
2. 接口名称就是匿名内部类需要实现哪个接口
3. {...}这才是匿名内部类的内容

另外注意内容
1. 匿名内部类在创建对象的时候,只能使用唯一的一次
> 如果希望多次创建对象,而且类的内容一样的话,那么就必须单独定义实现类
2. 匿名对象是在调用方法的时候,只能调用唯一一次,如果希望同一个对象调用多个方法,必须给匿名对象起名字
3. 匿名内部类是省略了实现类或者是子类,但是匿名对象是省略了对象名称
`强调:` 匿名内部类和匿名对象不是一回事!

