---
title: 2022前端面试综合汇总 P7版
date: 2022-02-28 16:21:54
permalink: /pages/045764/
categories:
  - 更多
  - 面试
tags:
  - null
---

## 请做一下自我介绍

**回答：** 面试官你好,我叫xxx,巴拉巴拉

## 介绍一下你做的项目

**回答：** 首先是xxx项目.我参与了xxx 其中xxx


## HTML

### 1.html语义化
html语义化就是用合适的标签来标记和合适的内容

**语义化的好处** 
- 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息。
- 方便其他设备（如屏幕阅读器、盲人阅读器、移动设备）更好的解析页面。
- 使代码更具可读性，便于团队开发和维护
- 网页加载慢导致CSS文件还未加载时（没有CSS），页面仍然清晰、可读、好看

**语义化标签**
- `header footer nav`(导航链接区域)
- `aside` 通常被包含在article元素中作为主要内容的附属信息部分
- `section` section元素代表文档中的“节”或“段”
- `article` article代表一个在文档，页面或者网站中自成一体的内容,比如论坛帖子
- `h1 - h6` 标题，根据级别依次递减 h1一个页面最好只有一个
- `p` 内容段落

### 2.行内元素和块级元素
**行内元素**
- 不会独占一行,相邻的行内元素会排列在同一行里,直到一行排不下,才会换行
- 行内元素设置width,height属性无效
- 行内元素的margin和padding只在水平方向有效果

> 标签：a img input label select strong textarea

**块级元素**

- 会独占一行,默认情况下,其宽度自动填满其父元素宽度
- 块级元素可以设置width,height属性.
- 块级元素即使设置了宽度,仍然是独占一行.
- 块级元素可以设置margin和padding属性

> 标签： div p form h1-h6 ul ol

**行内块级元素**

结合的行内和块级的优点，既可以设置长宽，可以让padding和margin生效，又可以和其他行内元素并排


### 3.meta标签

`<meta>` 标签提供关于 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务

``` html
// 声明文档编码
<meta charset="utf-8">
//页面关键字
<meta name="keywords" content="your keywords">
// 页面描述内容
<meta name="description" content="your description">
// 定义网页作者
<meta name="author" content="author,email address">
//移动端布局参数设置
<meta name="viewport" content="width=device-width, initial-scale=1.0">
content参数如下：
-   width viewport 宽度(数值/device-width)
-   height viewport 高度(数值/device-height)
-   initial-scale 初始缩放比例
-   maximum-scale 最大缩放比例
-   minimum-scale 最小缩放比例
-   user-scalable 是否允许用户缩放(yes/no)
//各个浏览器的meta标签有不同的自定义功能 包括 chrome 360 UC 等等

<!-- 优先使用最新的chrome版本 --> 
<meta http-equiv="X-UA-Compatible" content="chrome=1" /> 
<!-- 禁止自动翻译 -->
<meta name="google" value="notranslate">

```

### 4.script 标签中 defer 和 async 的区别？
- `script` ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
- `async script` ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。
- `defer script`：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本

## CSS

### 1. 盒模型
CSS3 中的盒模型有以下两种：标准盒模型、IE（替代）盒模型。
两种盒子模型都是由 `content + padding + border + margin` 构成，其大小都是由` content + padding + border` 决定的，但是盒子内容宽/高度（即 width/height）的计算范围根据盒模型的不同会有所不同：

标准盒模型：只包含 `content `。

IE（替代）盒模型：`content + padding + border `。

可以通过` box-sizing `来改变元素的盒模型：

- `box-sizing: content-box` ：标准盒模型（默认值）。
- `box-sizing: border-box` ：IE（替代）盒模型。

### 2. 重排（reflow）和重绘（repaint）的理解
**简单地总结下两者的概念：** 
* 重排：无论通过什么方式影响了元素的几何信息(元素在视口内的位置和尺寸大小)，浏览器需要重新计算元素在视口内的几何属性，这个过程叫做重排。
* 重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘

**如何减少重排和重绘？**
* 最小化重绘和重排，比如样式集中改变，使用添加新样式类名 .class 或 cssText 。
* 批量操作 DOM，比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 document.createDocumentFragment() 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。
* 使用 **absolute** 或 **fixed** 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显。
* 开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。

### 3. 对 BFC 的理解
BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做视觉格式化模型的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分，**用于决定块级盒的布局及浮动相互影响范围的一个区域。**

BFC 具有一些特性：

1. 块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。
2. 在 BFC 中上下相邻的两个容器的 margin  会重叠，创建新的 BFC 可以避免外边距重叠。
3. 计算 BFC 的高度时，需要计算浮动元素的高度。
4. BFC 区域不会与浮动的容器发生重叠。
5. BFC 是独立的容器，容器内部元素不会影响外部元素。
6. 每个元素的左 margin  值和容器的左 border  相接触。

利用这些特性，我们可以解决以下问题：

* 利用 4  和 6 ，我们可以实现三栏（或两栏）自适应布局。
* 利用 2 ，我们可以避免 margin  重叠问题。
* 利用 3 ，我们可以避免高度塌陷。

创建 BFC 的方式：

* 绝对定位元素（position 为 absolute 或 fixed ）。
* 行内块元素，即 display 为 inline-block 。
* overflow 的值不为 visible 。

### 4. 水平垂直居中多种实现方式
1. 利用绝对定位，设置 left: 50%  和 top: 50%  现将子元素左上角移到父元素中心位置，然后再通过 translate  来调整子元素的中心点到父元素的中心。该方法可以不定宽高。

``` css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
```

2. 利用绝对定位，子元素所有方向都为 0 ，将 margin  设置为 auto ，由于宽高固定，对应方向实现平分，该方法必须盒子有宽高。
``` css
.father {
  position: relative;
}
.son {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0px;
  margin: auto;
  height: 100px;
  width: 100px;
}

```

3. 利用绝对定位，设置 left: 50% 和 top: 50% 现将子元素左上角移到父元素中心位置，然后再通过 margin-left  和 margin-top  以子元素自己的一半宽高进行负值赋值。**该方法必须定宽高**。
``` css
.father {
  position: relative;
}
.son {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 200px;
  height: 200px;
  margin-left: -100px;
  margin-top: -100px;
}
```

4. 利用 flex ，最经典最方便的一种了，不用解释，定不定宽高无所谓的。
``` css
.father {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

## JavaScript   

### 1. js都有哪些数据类型,他们的区别

::: tip
JavaScript目前有八种数据类型,分别是`undefined,nul,boolean,number,string,object,symbol,bigint`,其中symbol和bigint是ES6新增的数据类型
:::
* symbol: 代表创建后独一无二且不可变的数据类型,它主要是为了解决可能出现的全局变量冲突的问题。
* bigint: 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围

这些数据可以分为原始数据类型和引用数据类型：
* 栈：原始数据类型（Undefined、Null、Boolean、Number、String）
* 堆：引用数据类型（对象、数组和函数）

两种类型的区别在于存储位置的不同：
* 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
* 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：
* 在数据结构中，栈中数据的存取方式为先进后出。
* 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。

### 2. 数据类型检测的方式有哪些

::: tip
常用的有`typeof`, `instanceof`, `constructor`, `Object.prototype.toString.call()`
:::

* typeof
``` js
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof []);              // object    
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object
```
使用 typeof 判断类型,其中数组、对象、null都会被判断为object，其他判断都正确。
* instanceof    
`instanceof` 可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。
``` js
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false 
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
```
可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性

* constructor
``` js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
```
`constructor`有两个作用，一是判断数据的类型，二是对象实例通过 `constrcutor` 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：
``` js
function Fn(){};
 
Fn.prototype = new Array();
 
var f = new Fn();
 
console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true

```
* Object.prototype.toString.call()     
使用 Object 对象的原型方法 toString 来判断数据类型：
``` js
var a = Object.prototype.toString;
console.log(a.call(2));
console.log(a.call(true));
console.log(a.call('str'));
console.log(a.call([]));
console.log(a.call(function(){}));
console.log(a.call({}));
console.log(a.call(undefined));
console.log(a.call(null));
```
同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？   
这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。

### 3. 判断数组的方式有哪些
::: tip
通过Object.prototype.toString.call()做判断,通过原型链做判断,通过ES6的Array.isArray()做判断,通过instanceof做判断,通过Array.prototype.isPrototypeOf做判断
:::

